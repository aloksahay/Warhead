-- Enable necessary extensions
create extension if not exists "postgis";

-- Create enum types
create type missile_status as enum ('ready', 'in_flight', 'exploded', 'destroyed');
create type player_status as enum ('alive', 'dead');

-- Create players table
create table public.players (
  id uuid references auth.users on delete cascade,
  nickname text not null,
  wallet_address text unique,
  location geometry(Point, 4326),
  status player_status default 'alive',
  shield_points integer default 100,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  primary key (id)
);

-- Create missiles table
create table public.missiles (
  id bigint generated by default as identity primary key,
  token_id bigint unique not null,
  type integer not null,
  owner_id uuid references public.players(id) on delete cascade,
  status missile_status default 'ready',
  launch_time timestamptz,
  target_location geometry(Point, 4326),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Create missile_impacts table
create table public.missile_impacts (
  id bigint generated by default as identity primary key,
  missile_id bigint references public.missiles(id) on delete cascade,
  target_id uuid references public.players(id) on delete cascade,
  damage integer not null,
  impact_location geometry(Point, 4326) not null,
  impact_time timestamptz default now()
);

-- Enable Row Level Security
alter table public.players enable row level security;
alter table public.missiles enable row level security;
alter table public.missile_impacts enable row level security;

-- Create RLS Policies

-- Players table policies
create policy "Players can read other players' public info"
  on public.players for select
  using (true);

create policy "Players can update their own info"
  on public.players for update
  using (auth.uid() = id);

-- Missiles table policies
create policy "Players can view all missiles"
  on public.missiles for select
  using (true);

create policy "Players can only create missiles they own"
  on public.missiles for insert
  with check (auth.uid() = owner_id);

create policy "Players can only update their own missiles"
  on public.missiles for update
  using (auth.uid() = owner_id);

-- Missile impacts table policies
create policy "Anyone can view missile impacts"
  on public.missile_impacts for select
  using (true);

create policy "Only missile owners can create impacts"
  on public.missile_impacts for insert
  using (
    exists (
      select 1 from public.missiles
      where id = missile_impacts.missile_id
      and owner_id = auth.uid()
    )
  );

-- Create functions

-- Function to update player location
create or replace function public.update_player_location(
  p_latitude double precision,
  p_longitude double precision
) returns void as $$
begin
  update public.players
  set 
    location = ST_SetSRID(ST_MakePoint(p_longitude, p_latitude), 4326),
    updated_at = now()
  where id = auth.uid();
end;
$$ language plpgsql security definer;

-- Function to launch missile
create or replace function public.launch_missile(
  p_missile_id bigint,
  p_target_id uuid,
  p_user_id uuid
) returns json as $$
declare
  v_missile record;
  v_target record;
  v_damage integer;
  v_impact_id bigint;
begin
  -- Get missile info
  select * into v_missile
  from public.missiles
  where id = p_missile_id and owner_id = p_user_id and status = 'ready';
  
  if not found then
    raise exception 'Missile not found or not ready';
  end if;

  -- Get target info
  select * into v_target
  from public.players
  where id = p_target_id and status = 'alive';
  
  if not found then
    raise exception 'Target not found or already dead';
  end if;

  -- Calculate damage based on missile type
  v_damage := 20 + (v_missile.type * 10);

  -- Update missile status
  update public.missiles
  set 
    status = 'in_flight',
    launch_time = now(),
    target_location = v_target.location,
    updated_at = now()
  where id = p_missile_id;

  -- Create impact record
  insert into public.missile_impacts (
    missile_id,
    target_id,
    damage,
    impact_location
  ) values (
    p_missile_id,
    p_target_id,
    v_damage,
    v_target.location
  ) returning id into v_impact_id;

  -- Update target's shield points
  update public.players
  set 
    shield_points = greatest(0, shield_points - v_damage),
    status = case 
      when shield_points - v_damage <= 0 then 'dead'::player_status 
      else status 
    end,
    updated_at = now()
  where id = p_target_id;

  -- Return launch result
  return json_build_object(
    'success', true,
    'missile_id', p_missile_id,
    'impact_id', v_impact_id,
    'damage', v_damage,
    'target_id', p_target_id
  );
end;
$$ language plpgsql security definer;

-- Create triggers

-- Update timestamps trigger
create or replace function public.update_timestamps()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger update_players_timestamp
  before update on public.players
  for each row
  execute function public.update_timestamps();

create trigger update_missiles_timestamp
  before update on public.missiles
  for each row
  execute function public.update_timestamps();

-- Create realtime publication
create publication supabase_realtime for table 
  players,
  missiles,
  missile_impacts; 